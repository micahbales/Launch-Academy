## Introduction

Reading and writing CSV files works for small applications, but if we want our [News Aggregator](/lessons/news-aggregator) to take over the world we're going to need something a little more heavy-duty. Let's redesign our persistence layer so that we're reading from and writing to a PostgreSQL database rather than directly to a file.

### Learning Objectives

* Define a database schema to store user-submitted articles.
* Read from and write information to a PostgreSQL database from a Sinatra application.

### Instructions

There are two steps involved when converting an app from CSV files to PostgreSQL: defining the schema and modifying the application.

#### Define the Schema

Before we can start writing to PostgreSQL we need to create a new database and define a schema. To create a new database named `news_aggregrator_development` run the following command:

```no-highlight
$ createdb news_aggregator_development
```

Now consider how you want to store the articles in your database. Within the *schema.sql* file, uncomment the `CREATE TABLE` SQL statement and add the appropriate column definitions for the *articles* table (`--` starts a comment in SQL). To execute these SQL statements against the database, run the following command:

```no-highlight
$ psql news_aggregator_development < schema.sql
```

#### Modify the Web Application

Expanding upon the web application built in the [News Aggregator](/lessons/news-aggregator) challenge, replace any calls that modify the CSV file with similar calls that communicate to the database created in the previous step. This should involve updating the `POST` request to write a new article to the database and the `GET` request to query for all articles.

Acceptance tests have been written for you that cover the core functionality of the original application. By getting these tests to pass, you will ensure that your application has not experienced any regressions. Ignore the pending tests until you get to the optional part of this challenge.

**Important:** Previously, your application only had one source of data which was deleted whenever the test suite was run. However, your app will now have two sources of data:
1. A development database that your application will use when the application is run on your local machine (for this challenge the name of the database is `news_aggregator_development`).
2. A test database that will be used by your test suite (for this challenge the name of the database is `news_aggregator_test`).

By having two databases, the data that you generated by using your app will not be modified, and your tests will have a place to create records. Your test suite will take care of creating the test database and loading it with your schema, so you do not have to worry about that part of the test setup.  Remember that your test database will have no data at the beginning of every `it` and `scenario` blocks. If the test requires some data, you will need to seed data at the beginning of the test. For an example, take a look at `user_sees_articles_spec.rb`.

### Tips

* Remember, users will try to do evil things to your app. Use the `exec_params` method with the `pg` gem to prevent users from running malicious SQL statements against the database.
* To enforce URL uniqueness in the database you may want to look at [unique indexes](http://www.postgresql.org/docs/9.4/static/indexes-unique.html) in PostgreSQL.

### Optional Challenges
1. Change `xdescribe` to `describe` in `spec/models/article_spec.rb` and then get these tests to pass.
2. Change `xcontext` to `context` in spec/features/user_adds_article_spec.rb` and then get these tests to pass.
3. Use your `Article` object throughout your application.
